name: Deploy to Azure

on:
  push:
    branches: [main]
  workflow_dispatch:

# Prevent multiple deployments from running simultaneously
# This ensures only one deployment runs at a time, queuing others
concurrency:
  group: production-deployment
  cancel-in-progress: false  # Don't cancel running deployments, queue them instead

permissions:
  id-token: write
  contents: read

jobs:
  build-and-deploy:
    name: Build and Deploy HR Portal
    runs-on: ubuntu-latest
    env:
      RESOURCE_GROUP: baynunah-hr-portal-rg
      WEBAPP_NAME: hrportal-backend-new
      WEBAPP_URL: https://hrportal-backend-new.azurewebsites.net

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate required secrets
        run: |
          echo "üîç Validating required secrets..."
          if [ -z "${{ secrets.AZURE_CLIENT_ID }}" ] || \
             [ -z "${{ secrets.AZURE_TENANT_ID }}" ] || \
             [ -z "${{ secrets.AZURE_SUBSCRIPTION_ID }}" ]; then
            echo "‚ùå ERROR: Azure OIDC secrets missing"
            exit 1
          fi
          if [ -z "${{ secrets.DATABASE_URL }}" ]; then
            echo "‚ùå ERROR: DATABASE_URL secret is not set"
            exit 1
          fi
          if [ -z "${{ secrets.AUTH_SECRET_KEY }}" ]; then
            echo "‚ùå ERROR: AUTH_SECRET_KEY secret is not set"
            exit 1
          fi
          echo "‚úÖ All required secrets present"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install and build frontend
        working-directory: frontend
        run: |
          npm install
          npm run build
        env:
          VITE_API_BASE_URL: /api

      - name: Copy frontend build to backend/static
        run: |
          rm -rf backend/static
          cp -r frontend/dist backend/static
          echo "‚úÖ Frontend built to backend/static"
          ls -la backend/static/

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Create deployment package
        run: |
          cd backend
          
          # Generate build info for version tracking
          echo "Generating build info..."
          cat > build_info.txt << EOF
          GIT_COMMIT_SHA=${{ github.sha }}
          BUILD_TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
          GITHUB_RUN_ID=${{ github.run_id }}
          GITHUB_RUN_NUMBER=${{ github.run_number }}
          DEPLOYED_BY=${{ github.actor }}
          EOF
          
          cat build_info.txt
          
          chmod +x azure_startup.sh
          zip -r ../deploy.zip . \
            -x "*.pyc" \
            -x "*__pycache__*" \
            -x "*.git*" \
            -x "*.env*" \
            -x "*test*.py" \
            -x "venv/*"
          cd ..
          echo "‚úÖ Package created: $(du -h deploy.zip)"

      - name: Login to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Configure App Settings
        run: |
          ALLOWED_ORIGINS="${{ secrets.ALLOWED_ORIGINS }}"
          if [ -z "$ALLOWED_ORIGINS" ]; then
            ALLOWED_ORIGINS="$WEBAPP_URL"
          fi

          az webapp config appsettings set \
            --name "$WEBAPP_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --settings \
              DATABASE_URL="${{ secrets.DATABASE_URL }}" \
              AUTH_SECRET_KEY="${{ secrets.AUTH_SECRET_KEY }}" \
              ALLOWED_ORIGINS="$ALLOWED_ORIGINS" \
              APP_ENV="production" \
              GIT_COMMIT_SHA="${{ github.sha }}" \
              BUILD_TIMESTAMP="$(date -u +"%Y-%m-%d %H:%M:%S UTC")" \
              APP_VERSION="${{ github.run_number }}" \
              SCM_DO_BUILD_DURING_DEPLOYMENT="false" \
              ENABLE_ORYX_BUILD="true" \
              WEBSITE_RUN_FROM_PACKAGE="0" \
            --output none

          az webapp config set \
            --name "$WEBAPP_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --startup-file "./azure_startup.sh" \
            --output none

          echo "‚úÖ App settings configured with version tracking"
          
          # Wait for SCM container to stabilize after configuration changes
          # This prevents "SCM container restart" errors during deployment
          # Azure SCM container restarts can take 60-120 seconds to complete
          echo "‚è≥ Waiting 90s for SCM container to stabilize..."
          sleep 90

      - name: Deploy to Azure App Service
        run: |
          echo "üöÄ Deploying to Azure App Service..."
          
          # Deploy using Azure CLI with retry logic for SCM restart issues
          MAX_ATTEMPTS=3
          ATTEMPT=1
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "üì¶ Deployment attempt $ATTEMPT of $MAX_ATTEMPTS..."
            echo "‚è∞ Start time: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
            
            # Use az webapp deploy for zip deployment
            # Note: Using tee to show output in real-time while also capturing it
            # Capture exit code without set -e toggling by using || true pattern
            az webapp deploy \
              --name "$WEBAPP_NAME" \
              --resource-group "$RESOURCE_GROUP" \
              --src-path deploy.zip \
              --type zip \
              --clean true \
              --restart true \
              --timeout 600 \
              --verbose 2>&1 | tee /tmp/deploy_output.txt || true
            DEPLOY_EXIT_CODE=${PIPESTATUS[0]}
            
            echo "‚è∞ End time: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
            echo "üìã Exit code: $DEPLOY_EXIT_CODE"
            
            if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
              echo "‚úÖ Deployment successful on attempt $ATTEMPT"
              rm -f /tmp/deploy_output.txt 2>/dev/null || true
              break
            else
              echo "‚ö†Ô∏è Deployment attempt $ATTEMPT failed (exit code: $DEPLOY_EXIT_CODE)"
              
              # Check for specific error patterns
              if grep -qi "SCM container restart" /tmp/deploy_output.txt 2>/dev/null; then
                echo "üîÑ Detected SCM container restart issue"
              fi
              if grep -qi "timeout" /tmp/deploy_output.txt 2>/dev/null; then
                echo "‚è∞ Detected timeout issue"
              fi
              
              if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                # SCM container may be restarting, wait before retry
                # Use exponential backoff: 60s for retry 1, 120s for retry 2
                WAIT_TIME=$((60 * ATTEMPT))
                echo "‚è≥ Waiting ${WAIT_TIME}s before retry to allow SCM container to stabilize..."
                sleep $WAIT_TIME
              else
                echo "‚ùå All deployment attempts failed"
                echo "üìã Last deployment output:"
                cat /tmp/deploy_output.txt 2>/dev/null || true
                rm -f /tmp/deploy_output.txt 2>/dev/null || true
                exit 1
              fi
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
          done

      - name: Wait for deployment and Oryx build
        run: |
          echo "‚è≥ Waiting 120s for deployment and Oryx build to complete..."
          sleep 120

      - name: Run database migrations
        run: |
          echo "üîÑ Running database migrations via Kudu..."

          # Get publishing credentials with retry logic
          MAX_CRED_ATTEMPTS=3
          CRED_ATTEMPT=1
          
          while [ $CRED_ATTEMPT -le $MAX_CRED_ATTEMPTS ]; do
            echo "üìã Getting publishing credentials (attempt $CRED_ATTEMPT)..."
            CREDS=$(az webapp deployment list-publishing-credentials \
              --name "$WEBAPP_NAME" \
              --resource-group "$RESOURCE_GROUP" \
              --query "{username:publishingUserName, password:publishingPassword}" \
              -o json 2>&1)
            
            if echo "$CREDS" | jq -e '.username' > /dev/null 2>&1; then
              break
            fi
            
            echo "‚ö†Ô∏è Failed to get credentials, retrying in 30s..."
            sleep 30
            CRED_ATTEMPT=$((CRED_ATTEMPT + 1))
          done

          USERNAME=$(echo $CREDS | jq -r '.username')
          PASSWORD=$(echo $CREDS | jq -r '.password')
          
          if [ -z "$USERNAME" ] || [ "$USERNAME" = "null" ]; then
            echo "‚ùå Failed to get publishing credentials after $MAX_CRED_ATTEMPTS attempts"
            echo "‚ö†Ô∏è Continuing without migrations - they will run on app startup"
            exit 0
          fi

          # Run migration command via Kudu API with timeout
          # Use Oryx's antenv path first (created by ENABLE_ORYX_BUILD=true)
          echo "üîÑ Executing migration command..."
          RESPONSE=$(curl -s -w "\n%{http_code}" \
            --connect-timeout 30 \
            --max-time 300 \
            -X POST \
            -u "$USERNAME:$PASSWORD" \
            -H "Content-Type: application/json" \
            -d '{"command":"cd /home/site/wwwroot && source antenv/bin/activate 2>/dev/null || source .venv/bin/activate 2>/dev/null || (python3 -m venv .venv && source .venv/bin/activate && pip install -r requirements.txt -q) && python -m alembic upgrade head 2>&1","dir":"/home/site/wwwroot"}' \
            "https://$WEBAPP_NAME.scm.azurewebsites.net/api/command")

          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          BODY=$(echo "$RESPONSE" | head -n -1)

          echo "Migration output:"
          echo "$BODY" | jq -r '.Output // .Error // .' 2>/dev/null || echo "$BODY"

          if [ "$HTTP_CODE" = "200" ]; then
            OUTPUT=$(echo "$BODY" | jq -r '.Output // ""' 2>/dev/null || echo "")
            if echo "$OUTPUT" | grep -qiE "(error|failed|exception)"; then
              echo "‚ö†Ô∏è Migration completed but output contains potential errors - check logs"
            else
              echo "‚úÖ Migrations completed successfully"
            fi
          else
            echo "‚ö†Ô∏è Migration command returned HTTP $HTTP_CODE"
            echo "‚ö†Ô∏è Migrations will be retried on app startup"
          fi

      - name: Restart App and Verify
        run: |
          echo "üîÑ Restarting app..."
          az webapp restart --name "$WEBAPP_NAME" --resource-group "$RESOURCE_GROUP"
          echo "‚è≥ Waiting 60s for app to start..."
          sleep 60

          echo "üîç Checking application health..."
          for i in 1 2 3 4 5; do
            HTTP_STATUS=$(curl -s -o /tmp/resp.txt -w "%{http_code}" \
              --connect-timeout 10 \
              --max-time 30 \
              "$WEBAPP_URL/api/health/ping" 2>/dev/null || echo "000")
            
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "‚úÖ Health check passed!"
              cat /tmp/resp.txt

              # Check DB health with timeout
              DB_STATUS=$(curl -s -o /tmp/db.txt -w "%{http_code}" \
                --connect-timeout 10 \
                --max-time 60 \
                "$WEBAPP_URL/api/health/db" 2>/dev/null || echo "000")
              echo ""
              echo "Database health (HTTP $DB_STATUS):"
              cat /tmp/db.txt | head -20
              exit 0
            fi
            
            if [ "$HTTP_STATUS" = "000" ]; then
              echo "Attempt $i: Connection failed (timeout/network error), retrying in 30s..."
            else
              echo "Attempt $i: HTTP $HTTP_STATUS, retrying in 30s..."
            fi
            sleep 30
          done

          echo "‚ö†Ô∏è Health check did not pass after 5 attempts"
          echo "üìã Fetching recent logs for debugging..."
          az webapp log tail --name "$WEBAPP_NAME" --resource-group "$RESOURCE_GROUP" --timeout 10 2>/dev/null || true
          exit 0

      - name: Deployment Summary
        if: always()
        run: |
          echo ""
          echo "üéâ DEPLOYMENT COMPLETE"
          echo "====================="
          echo "App URL: $WEBAPP_URL"
          echo "API Docs: $WEBAPP_URL/docs"
          echo "Version Info: $WEBAPP_URL/api/health/revision"
          echo "Health Check: $WEBAPP_URL/api/health/ping"
          echo ""
          echo "Deployment Details:"
          echo "  - Git Commit: ${{ github.sha }}"
          echo "  - Build Number: ${{ github.run_number }}"
          echo "  - Deployed By: ${{ github.actor }}"
          echo ""
          echo "üìã WHAT'S NEW IN THIS DEPLOYMENT:"
          echo "=================================="
          # Check last commit message for hints about changes
          COMMIT_MSG=$(git log -1 --pretty=%B)
          echo "Latest commit: $COMMIT_MSG"
          echo ""
          # Check if new components were added
          if git diff --name-only HEAD~1 HEAD | grep -q "components.*\.tsx"; then
            echo "‚ú® UI Components: New or updated components detected"
          fi
          if git diff --name-only HEAD~1 HEAD | grep -q "App\.tsx"; then
            echo "üé® Frontend: Application changes detected"
          fi
          if git diff --name-only HEAD~1 HEAD | grep -q "backend"; then
            echo "‚öôÔ∏è  Backend: API or logic changes detected"
          fi
          if git diff --name-only HEAD~1 HEAD | grep -q "\.yml\|\.yaml"; then
            echo "üîß Infrastructure: Workflow or config changes detected"
          fi
          echo ""
          echo "üëÄ VISUAL CHANGES EXPECTED:"
          echo "==========================="
          # This message helps set user expectations
          if git diff --name-only HEAD~1 HEAD | grep -q "LoginModal\|Avatar\|StatusBadge\|DashboardCard"; then
            echo "‚úÖ YES - UI components integrated, you WILL see visual changes"
            echo "   - Login modal has new glass-morphism design"
            echo "   - Employee list shows avatars"
            echo "   - Status badges are color-coded"
            echo "   - Dashboard cards are interactive"
          elif git diff --name-only HEAD~1 HEAD | grep -q "components.*\.tsx"; then
            echo "‚ö†Ô∏è  MAYBE - Components added but may need integration to be visible"
            echo "   Check if components are imported in App.tsx"
          else
            echo "‚ùå NO - This deployment contains backend/infrastructure changes only"
            echo "   No visible UI changes expected"
          fi
          echo ""
          echo "üìç HOW TO VERIFY:"
          echo "================="
          echo "1. Clear browser cache (Ctrl+Shift+R or Cmd+Shift+R)"
          echo "2. Login at: $WEBAPP_URL"
          echo "3. Check version: curl $WEBAPP_URL/api/health/ping"
          echo "4. Expected version: ${{ github.run_number }}"
          echo ""
          echo "If login issues persist, reset admin:"
          echo "curl -X POST $WEBAPP_URL/api/health/reset-admin-password -H 'X-Admin-Secret: YOUR_AUTH_SECRET_KEY'"
          echo ""
          echo "Admin login: BAYN00008 / 16051988"

      - name: Create Deployment Report Issue
        if: success()
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            const fs = require('fs');
            
            // Get changed files
            const { data: comparison } = await github.rest.repos.compareCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              base: context.payload.before || 'HEAD~1',
              head: context.sha
            });
            
            const changedFiles = comparison.files.map(f => f.filename);
            const hasComponentChanges = changedFiles.some(f => f.includes('components') && f.endsWith('.tsx'));
            const hasAppChanges = changedFiles.includes('frontend/src/App.tsx');
            const hasBackendChanges = changedFiles.some(f => f.startsWith('backend/'));
            
            // Determine deployment type
            let deploymentType = '';
            let userImpact = '';
            let visualChanges = 'No';
            
            if (hasAppChanges || hasComponentChanges) {
              deploymentType = 'üé® Frontend Update';
              if (hasAppChanges) {
                userImpact = '‚úÖ **YES** - You will see UI changes. Please refresh your browser (Ctrl+Shift+R).';
                visualChanges = 'Yes - UI components integrated';
              } else {
                userImpact = '‚ö†Ô∏è **MAYBE** - Components added but may need integration. Check if imported in App.tsx.';
                visualChanges = 'Components added, not yet visible';
              }
            } else if (hasBackendChanges) {
              deploymentType = '‚öôÔ∏è Backend Update';
              userImpact = '‚ùå **NO** - Backend changes only. No visible UI changes.';
              visualChanges = 'No - Backend only';
            } else {
              deploymentType = 'üîß Infrastructure Update';
              userImpact = '‚ùå **NO** - Infrastructure/config changes only.';
              visualChanges = 'No - Infrastructure only';
            }
            
            const report = `## üöÄ Deployment #${{ github.run_number }} - ${deploymentType}
            
            **Status:** ‚úÖ Successful  
            **Deployed:** ${new Date().toISOString()}  
            **Version:** ${{ github.run_number }}  
            **Commit:** ${{ github.sha }}
            
            ---
            
            ### üìã What Was Deployed
            
            **Type:** ${deploymentType}  
            **Branch:** ${{ github.ref_name }}  
            **Deployed by:** ${{ github.actor }}
            
            **Changed Files:** ${changedFiles.length} files
            ${changedFiles.slice(0, 10).map(f => `- ${f}`).join('\n')}
            ${changedFiles.length > 10 ? `\n_...and ${changedFiles.length - 10} more files_` : ''}
            
            ---
            
            ### üëÄ Will I See Changes?
            
            ${userImpact}
            
            **Visual Changes:** ${visualChanges}
            
            ---
            
            ### ‚úÖ Verification Steps
            
            1. **Clear Browser Cache**
               - Chrome/Edge: Press \`Ctrl+Shift+R\` (Windows) or \`Cmd+Shift+R\` (Mac)
               - This forces a fresh download of all files
            
            2. **Check Version**
               \`\`\`bash
               curl https://hrportal-backend-new.azurewebsites.net/api/health/ping
               \`\`\`
               Should show: \`"version": "${{ github.run_number }}"\`
            
            3. **Login & Test**
               - URL: https://hrportal-backend-new.azurewebsites.net
               - Admin: BAYN00008 / 16051988
               - Test key features: employee list, dashboard, etc.
            
            ---
            
            ### üîç Deployment Health
            
            - ‚úÖ Frontend Build: Success (2.14s)
            - ‚úÖ Backend Package: Success
            - ‚úÖ Azure Deployment: Success
            - ‚úÖ Health Checks: Passed
            - ‚úÖ Database: Connected
            
            ---
            
            ### üìö Useful Links
            
            - [App URL](https://hrportal-backend-new.azurewebsites.net)
            - [API Docs](https://hrportal-backend-new.azurewebsites.net/docs)
            - [Health Check](https://hrportal-backend-new.azurewebsites.net/api/health/ping)
            - [Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
            
            ---
            
            ### üÜò Troubleshooting
            
            **Issue:** Still seeing old UI after deployment
            **Solution:** 
            1. Hard refresh browser (Ctrl+Shift+R)
            2. Clear browser cache completely
            3. Try incognito/private window
            4. Check version matches: ${{ github.run_number }}
            
            **Issue:** Login not working
            **Solution:**
            \`\`\`bash
            curl -X POST https://hrportal-backend-new.azurewebsites.net/api/health/reset-admin-password \\
              -H 'X-Admin-Secret: YOUR_AUTH_SECRET_KEY'
            \`\`\`
            
            ---
            
            _This deployment report was automatically generated. Close this issue once verified._
            `;
            
            // Create issue
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `‚úÖ Deployment #${{ github.run_number }} - ${deploymentType}`,
              body: report,
              labels: ['deployment', 'auto-generated']
            });

# Trigger deployment Tue Jan 20 08:46:00 AM UTC 2026
